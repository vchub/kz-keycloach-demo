# Keycloak PHP OAuth2 Demo - Application Documentation

This document explains how the PHP application implements OAuth 2.0 authentication with Keycloak.

## üìã Table of Contents

- [Architecture Overview](#architecture-overview)
- [File Structure](#file-structure)
- [OAuth 2.0 Flow](#oauth-20-flow)
- [How index.php Works](#how-indexphp-works)
- [Configuration](#configuration)
- [Security Features](#security-features)
- [Session Management](#session-management)
- [Error Handling](#error-handling)
- [Troubleshooting](#troubleshooting)
- [Registration Flow](#registration)

---

## üèó Architecture Overview

This application uses the **OAuth 2.0 Authorization Code Flow** to authenticate users via Keycloak:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Browser   ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ  PHP App     ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ  Keycloak    ‚îÇ
‚îÇ             ‚îÇ         ‚îÇ  (index.php) ‚îÇ         ‚îÇ  Server      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Key Components:**

- **index.php** - Main application logic and UI
- **config.php** - Keycloak provider configuration
- **logout.php** - Handles user logout

---

## üìÅ File Structure

```
demo-php/
‚îú‚îÄ‚îÄ config.php          # Keycloak OAuth2 provider configuration
‚îú‚îÄ‚îÄ index.php           # Main application with OAuth flow
‚îú‚îÄ‚îÄ logout.php          # Logout handler
‚îú‚îÄ‚îÄ composer.json       # PHP dependencies
‚îî‚îÄ‚îÄ vendor/            # Composer dependencies
    ‚îî‚îÄ‚îÄ stevenmaguire/oauth2-keycloak/  # Keycloak OAuth2 library
```

---

## üîÑ OAuth 2.0 Flow

### Complete Authentication Flow

```
1. User visits index.php
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Not authenticated ‚Üí Shows "Login with Keycloak" link
   ‚îÇ
2. User clicks "Login with Keycloak" (?login=1)
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ PHP generates authorization URL with state parameter
   ‚îú‚îÄ‚ñ∫ Stores state in session for CSRF protection
   ‚îî‚îÄ‚ñ∫ Redirects to Keycloak login page
   ‚îÇ
3. User authenticates at Keycloak
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Enters username/password
   ‚îî‚îÄ‚ñ∫ Keycloak validates credentials
   ‚îÇ
4. Keycloak redirects back with authorization code
   ‚îÇ
   ‚îî‚îÄ‚ñ∫ URL: index.php?code=XXX&state=YYY
   ‚îÇ
5. PHP handles callback
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Verifies state parameter (CSRF protection)
   ‚îú‚îÄ‚ñ∫ Exchanges authorization code for access token
   ‚îú‚îÄ‚ñ∫ Stores token in session
   ‚îî‚îÄ‚ñ∫ Redirects to clean URL
   ‚îÇ
6. PHP fetches user information
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Calls Keycloak userinfo endpoint with access token
   ‚îî‚îÄ‚ñ∫ Gets user profile (name, email, etc.)
   ‚îÇ
7. Shows authenticated page
   ‚îÇ
   ‚îî‚îÄ‚ñ∫ Displays user info and logout option
```

---

## üîê How index.php Works

### Initialization

```php
require_once 'config.php';
```

- Loads Keycloak OAuth2 provider configuration
- Starts PHP session
- Initializes `$keycloak` provider object

---

### Step 1: Initiate Login (Lines 5-10)

**Trigger:** User clicks "Login with Keycloak" (`?login=1`)

```php
if (isset($_GET['login'])) {
    $authUrl = $keycloak->getAuthorizationUrl();
    $_SESSION['oauth2state'] = $keycloak->getState();
    header('Location: ' . $authUrl);
    exit;
}
```

**What happens:**

1. **Generate Authorization URL**
   - Creates URL to Keycloak's authorization endpoint
   - Includes parameters: `client_id`, `redirect_uri`, `scope`, `state`, `response_type=code`

2. **Store State Parameter**
   - Random string generated by the library
   - Saved in `$_SESSION['oauth2state']`
   - Used later to prevent CSRF attacks

3. **Redirect to Keycloak**
   - User is sent to Keycloak's login page

**Example Authorization URL:**

```
http://localhost:8080/realms/myrealm/protocol/openid-connect/auth
  ?client_id=php-app
  &redirect_uri=http://localhost:4000/index.php
  &state=abc123def456
  &scope=openid+profile+email
  &response_type=code
```

---

### Step 2: Handle Keycloak Callback (Lines 13-31)

**Trigger:** Keycloak redirects back with `?code=...&state=...`

```php
if (isset($_GET['code'])) {
    // Verify state to prevent CSRF attacks
    if (empty($_GET['state']) || empty($_SESSION['oauth2state'])
        || $_GET['state'] !== $_SESSION['oauth2state']) {
        unset($_SESSION['oauth2state']);
        die('Invalid state parameter');
    }

    unset($_SESSION['oauth2state']);

    try {
        $token = $keycloak->getAccessToken('authorization_code', [
            'code' => $_GET['code']
        ]);
        $_SESSION['token'] = $token;
        header('Location: /index.php');
        exit;
    } catch (Exception $e) {
        die('Failed to get access token: ' . $e->getMessage());
    }
}
```

**What happens:**

1. **State Verification (CSRF Protection)**
   - Compares `$_GET['state']` with `$_SESSION['oauth2state']`
   - If they don't match ‚Üí Security violation, abort
   - If they match ‚Üí Continue with token exchange

2. **Exchange Authorization Code for Access Token**
   - Sends POST request to Keycloak token endpoint
   - Includes: `code`, `client_id`, `client_secret`, `redirect_uri`, `grant_type`
   - Receives back:

     ```json
     {
       "access_token": "eyJhbGc...",
       "refresh_token": "eyJhbGc...",
       "id_token": "eyJhbGc...",
       "token_type": "Bearer",
       "expires_in": 300
     }
     ```

3. **Store Token in Session**
   - `$_SESSION['token']` contains the `AccessToken` object
   - Includes access token, refresh token, expiration time

4. **Redirect to Clean URL**
   - Removes `?code=...&state=...` from URL
   - Prevents issues if user refreshes page

---

### Step 3: Fetch User Information (Lines 34-52)

**Trigger:** Token exists in session

```php
if (isset($_SESSION['token'])) {
    try {
        $resourceOwner = $keycloak->getResourceOwner($_SESSION['token']);
    } catch (Exception $e) {
        // Token might be expired, try to refresh it
        try {
            $newToken = $keycloak->getAccessToken('refresh_token', [
                'refresh_token' => $_SESSION['token']->getRefreshToken()
            ]);
            $_SESSION['token'] = $newToken;
            $resourceOwner = $keycloak->getResourceOwner($newToken);
        } catch (Exception $e) {
            // If refresh fails, clear session and re-authenticate
            unset($_SESSION['token']);
            header('Location: /index.php');
            exit;
        }
    }
}
```

**What happens:**

1. **Get User Profile**
   - Calls Keycloak's userinfo endpoint: `/protocol/openid-connect/userinfo`
   - Sends access token in `Authorization: Bearer <token>` header
   - Returns user details:

     ```json
     {
       "sub": "user-uuid",
       "name": "John Doe",
       "email": "john@example.com",
       "preferred_username": "john",
       "email_verified": true
     }
     ```

2. **Handle Token Expiration**
   - If access token is expired, API call fails
   - Catch exception and attempt token refresh

3. **Token Refresh Flow**
   - Use refresh token to get new access token
   - Update session with new token
   - Retry fetching user info

4. **Refresh Failure**
   - If refresh token is also expired/invalid
   - Clear session and redirect to login

---

### Step 4: Display UI (Lines 55-84)

**Authenticated View:**

```php
if (isset($resourceOwner)):
```

- Welcome message with user's name
- User details in formatted JSON
- Access token display
- Logout link

**Unauthenticated View:**

```php
else:
```

- "You are not authenticated" message
- "Login with Keycloak" link

---

## ‚öôÔ∏è Configuration

### config.php

```php
<?php
require_once __DIR__ . '/vendor/autoload.php';

session_start();

$keycloak = new Stevenmaguire\OAuth2\Client\Provider\Keycloak([
    'authServerUrl' => 'http://localhost:8080',
    'realm'         => 'myrealm',
    'clientId'      => 'php-app',
    'clientSecret'  => 'BgMEn9XoAvIo9qwcE9BOoCBdVdhnufgi',
    'redirectUri'   => 'http://localhost:4000/index.php',
    'version'       => '20.0.0'  // For Keycloak 20.x and later
]);
?>
```

**Configuration Parameters:**

| Parameter       | Description                            | Example                           |
| --------------- | -------------------------------------- | --------------------------------- |
| `authServerUrl` | Keycloak server base URL               | `http://localhost:8080`           |
| `realm`         | Keycloak realm name                    | `myrealm`                         |
| `clientId`      | OAuth2 client ID                       | `php-app`                         |
| `clientSecret`  | OAuth2 client secret                   | Generated in Keycloak             |
| `redirectUri`   | Callback URL after login               | `http://localhost:4000/index.php` |
| `version`       | Keycloak version for URL compatibility | `20.0.0`                          |

---

## üîí Security Features

### 1. **State Parameter (CSRF Protection)**

- Random token generated for each login attempt
- Stored in server-side session
- Verified when Keycloak redirects back
- Prevents Cross-Site Request Forgery attacks

### 2. **Authorization Code Flow**

- Most secure OAuth2 flow for server-side applications
- Authorization code exchanged server-to-server
- Client secret never exposed to browser
- Access token never in URL

### 3. **Token Storage**

- Tokens stored in PHP session (server-side)
- Never stored in cookies or localStorage
- Protected by PHP session security

### 4. **Automatic Token Refresh**

- Detects expired access tokens
- Uses refresh token to get new access token
- Seamless user experience without re-login

### 5. **Session Security**

```php
session_start();
```

- Enable `session.cookie_httponly` in php.ini (prevents XSS)
- Enable `session.cookie_secure` in production (HTTPS only)
- Set `session.cookie_samesite` to `Strict` or `Lax`

---

## üóÑÔ∏è Session Management

### Session Data Structure

```php
$_SESSION = [
    // Temporary - only during OAuth flow
    'oauth2state' => 'random_string_for_csrf_protection',

    // Persistent - while user is logged in
    'token' => AccessToken {
        access_token: 'eyJhbGciOiJSUzI1NiIs...',
        refresh_token: 'eyJhbGciOiJIUzI1NiIs...',
        expires: 1729598400,
        resource_owner_id: null,
        id_token: 'eyJhbGciOiJSUzI1NiIs...'
    }
];
```

### Session Lifecycle

1. **Session Start** - `config.php` calls `session_start()`
2. **OAuth Flow** - Temporary `oauth2state` stored and removed
3. **Authenticated** - `token` persists across requests
4. **Logout** - `session_destroy()` clears all data

---

## üö® Error Handling

### Common Errors and Solutions

#### "Invalid state parameter"

**Cause:** CSRF protection triggered

- State parameter mismatch
- Session expired during login
- Multiple login attempts

**Solution:** Clear browser cookies and try again

#### "Failed to get access token"

**Cause:** Token exchange failed

- Invalid authorization code
- Code already used (codes are single-use)
- Client credentials incorrect

**Solution:** Check Keycloak client configuration

#### "Failed to get resource owner: Invalid response received from Authorization Server"

**Cause:** Userinfo endpoint issue

- Token expired or invalid
- Wrong Keycloak version in config
- Network/connectivity issue

**Solution:**

- Set correct `version` parameter in config
- Check Keycloak server is running
- Verify access token is valid

#### "\_\_PHP_Incomplete_Class"

**Cause:** Session deserialization before autoloader
**Solution:** Ensure `session_start()` comes AFTER `require 'vendor/autoload.php'`

---

## üîß Troubleshooting

### Debug Mode

Add debug output to see what's happening:

```php
// After getting token
echo '<pre>';
print_r([
    'access_token' => substr($token->getToken(), 0, 50) . '...',
    'expires' => date('Y-m-d H:i:s', $token->getExpires()),
    'has_refresh_token' => !empty($token->getRefreshToken())
]);
echo '</pre>';
```

### Check Keycloak Configuration

1. **Client Settings:**
   - Access Type: `confidential`
   - Valid Redirect URIs: `http://localhost:4000/*`
   - Web Origins: `http://localhost:4000`

2. **Client Scopes:**
   - Ensure `openid`, `profile`, `email` are included

3. **User Permissions:**
   - User must exist in the realm
   - User must have permission to access the client

### Test Endpoints Manually

```bash
# Test authorization endpoint
curl "http://localhost:8080/realms/myrealm/protocol/openid-connect/auth?client_id=php-app&response_type=code&redirect_uri=http://localhost:4000/index.php"

# Test userinfo endpoint (replace <TOKEN> with actual access token)
curl -H "Authorization: Bearer <TOKEN>" \
     http://localhost:8080/realms/myrealm/protocol/openid-connect/userinfo
```

---

### Registration Flow

1. User visits your app
2. Clicks "Create Account" button
3. Redirected to Keycloak registration page
4. Fills out: First Name, Last Name, Email, Username, Password
5. Submits form
6. Keycloak creates user
7. Automatically logs user in
8. Redirects back to your app
9. User sees their profile information

---

## üìö Additional Resources

- [OAuth 2.0 Specification](https://oauth.net/2/)
- [Keycloak Documentation](https://www.keycloak.org/documentation)
- [stevenmaguire/oauth2-keycloak Library](https://github.com/stevenmaguire/oauth2-keycloak)
- [PHP League OAuth2 Client](https://oauth2-client.thephpleague.com/)

---

## üéØ Key Takeaways

1. **OAuth 2.0 is NOT authentication** - it's an authorization framework, but we use it for authentication via OpenID Connect
2. **State parameter is critical** - always verify it to prevent CSRF attacks
3. **Authorization codes are single-use** - exchange immediately, don't refresh the callback page
4. **Access tokens expire** - implement refresh token logic for better UX
5. **Store tokens server-side** - never expose tokens to browser/JavaScript
6. **HTTPS in production** - OAuth2 requires secure communication

---

_Last updated: October 22, 2025_
